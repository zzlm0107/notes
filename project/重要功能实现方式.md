## 路由动态权限

一般来说，路由权限可以分为前端控制和后端控制。

**前端控制**：

原理：根据用户的角色信息，隐藏掉不允许访问的侧边栏和按钮等，然后在**路由表的meta对象里标识该页面可访问的角色**。然后在全局前置路由守卫里根据角色信息，判断用户是否可以进入对应页面（路由守卫判断主要是防止用户直接输入url访问）

缺点：必须提前维护好每个页面的可访问角色，每次修改都需要重新打包部署等，而且对于用户无权访问的路由，理论上就不应该挂载。

**后端控制**：

原理：由后端维护不同角色的权限，返回角色的权限路由表；前端定义好静态路由和全部权限路由，再根据后端返回的**角色权限路由表**与前端的**全部权限路由**比对，再将权限路由添加到真实路由里。

缺点：整套流程较为繁琐（但安全性更高，是业内常用的方式）



重点说一下后端控制：

1. 将前端页面的所有路由进行拆分暴露，分为**静态路由**（所有人都可以访问）；**异步路由**（需要权限才能访问）；以及**任意路由**（将匹配不到的路由重定向到404，由于需要放到最后，所以也需要拆分出来）
2. 静态路由直接挂载即可，异步路由需要在**获取到用户的可访问路由权限表**后进行过滤，得到属于用户自己的**个人异步路由表**。然后遍历进行`addRoute()`添加即可

```js
// pinia user仓库，存储请求到的用户信息
import { constantRoutes, asyncRoutes, anyRoutes } from '@/router/routes'

/**
 * 根据用户异步路由表过滤异步路由展示，routes即用户可访问的路由页面名
 */
function filterAsyncRoutes(asyncRoutes: RouteRecordRaw[], routes: string[]) {
  return asyncRoutes.filter(item => {
    if (routes.includes(item.name as string)) {
      if (item.children && item.children.length > 0) {
        item.children = filterAsyncRoutes(item.children, routes)
      }
      return true
    }
  })
}


/**
 * 通过token获取用户信息方法
 */
function getUserInfo() {
  return new Promise<userInfoType>((resolve, reject) => {
    reqUserInfo()
      .then(res => {
        if (res.data.code === 200) {
          userInfo.value = res.data.data

          // 过滤异步路由,深拷贝避免直接修改asyncRoutes，导致切换账号时异步路由变化
          const userAsyncRoutes = filterAsyncRoutes(cloneDeep(asyncRoutes), res.data.data.routes)
          menuRoutes.value = [...constantRoutes, ...userAsyncRoutes, ...anyRoutes]
          // 将异步路由动态添加到路由表上
          const addRoutes = [...userAsyncRoutes, ...anyRoutes]
          addRoutes.forEach(route => {
            router.addRoute(route)
          })

          resolve(userInfo.value)
        } else {
          reject(res.data.msg)
        }
      })
      .catch(error => {
        reject(error)
      })
  })
}
```

3. 还需要注意的一个问题是addRoute动态添加的路由并不是响应式的，需要路由刷新才可访问

   ```ts
   router.beforeEach(async (to, _, next) => {
     NProgress.start()
     document.title = to.meta.title ? setting.title + '-' + to.meta.title : setting.title
   
     if (userStore.token) {
       // 已登录
       if (to.path === '/login') {
         next('/home')
       } else {
         // 有用户信息且去往正常页面
         if (userStore.userInfo) {
           next()
         } else {
           // 没有用户信息，可能是刷新导致pinia仓库清空了，重新发请求获取
           try {
             await userStore.getUserInfo()
             // 这里是解决addRoute动态添加的路由已经添加上但没有响应式更新，此时直接访问导致的白屏问题
             // 让其继续重新访问原路径，相当于执行一次路由更新操作，刷新路由表，动态路由此时已经添加完毕
             next({ ...to })
           } catch (error) {
             localStorage.clear()
             userStore.$reset()
             next('/login')
           }
         }
       }
     } else {
       // 未登录
       to.path !== '/login' ? next('/login') : next()
     }
   })
   ```






## 手机号验证码登录

常规流程：

1. 用户输入手机号，点击获取验证码按钮.
2. 弹出验证模块，常见为滑动滑块验证或图片识字验证，验证成功后校验手机号合法性。
3. 手机号合法后，发请求携带手机号传给后端，后端对接短信服务厂商向该手机号发送验证码短信，并返回本次操作的标识uuid。
4. 前端收集用户输入的验证码，与手机号，uuid一并提交给后端，后端校验验证码准确性，是否过期等，准备派发token。





## web微信扫码登录

**官方文档参考 [微信开放文档 微信登录功能](https://developers.weixin.qq.com/doc/oplatform/Website_App/WeChat_Login/Wechat_Login.html)**

**[知乎文章介绍细节](https://zhuanlan.zhihu.com/p/347683336)**



常规流程：

```text
1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；
2. 通过code参数加上AppID和AppSecret等，通过API换取access_token；
3. 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。
```

获取access_token时序图：

![](https://res.wx.qq.com/op_res/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut)



首先当前网站已经在微信开放平台登记好，获取到了appid等相关信息，当用户点击进行微信登录时，

**具体实现流程：**

1. **请求CODE**

   **前端：** 打开一个链接请求：https://open.weixin.qq.com/connect/qrconnect?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect 携带上网站信息。该请求会打开一个包含登录二维码的页面。

   当用户微信扫码完毕后，将会重定向到redirect_uri的地址上，并且带上code和state参数，前端检测到重定向地址上出现code即可发请求传递给后端进行下一步。

   ```text
   redirect_uri?code=CODE&state=STATE
   ```

   

   但是为了更加美观和自定义，大部分情况下，我们并不希望再打开一个页面展示登录二维码，所以微信还提供了第二种获取	code的方式，将微信二维码内嵌到自己页面,然后通过长轮询不断检测用户是否扫码成功，成功时就会重定向到redirect_uri的地址上，携带CODE参数，前端同样检测到重定向地址上出现code即可发请求传递给后端进行下一步：

   ```text
   1：在页面中先引入如下JS文件（支持https）
   http://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js
   
   2：在需要使用微信登录的地方实例以下JS对象：
    var obj = new WxLogin({
      self_redirect:true,
      id:"login_container",  // 第三方页面显示二维码的容器id
      appid: "", 
      scope: "snsapi_login", 
      redirect_uri: "",
       state: "",
      style: "",
      href: ""
    });
   ```

2. **通过code获取access_token**

   **后端：** 后端拿到CODE后，即可通过code获取access_token，这一步操作必须要后端进行，前端不能拿到appid和secret，否则可能会泄露网站数据。

   ```text
   https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code
   
   正确返回：
   { 
     "access_token":"ACCESS_TOKEN", 
     "expires_in":7200, 
     "refresh_token":"REFRESH_TOKEN",
     "openid":"OPENID", 
     "scope":"SCOPE",
     "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
   }
   ```

3. **通过access_token调用接口**

   **后端：**获取access_token后，进行接口调用，获取微信用户信息。检测用户是否注册过，没有就注册一个，然后返回用户token。



流程图：(引用他人，仅供学习参考)

![](https://pic2.zhimg.com/80/v2-9fb290471df346948887d10944664ec5_720w.webp)







## web二维码支付

需要：认证过的微信公众账号，微信商户平台账号，支付宝商户平台账号，已备案域名，项目后台服务器

**[微信native支付开发文档](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_7_0.shtml)**





## 移动端支付

支付功能常见操作过程：

1. 商品详情页点击购买按钮
2. 进入确认订单页，查看订单信息，选择支付方式，点击提交订单按钮
3. 拉起相应微信或支付宝进行支付
4. 校验支付是否完成，进入支付成功页面



**前端完整流程**

1. 用户点击购买按钮

   **前端：**发请求携带 **用户信息，订单金额，所选商品信息等** 重要信息。

   **后端：**生成订单信息，存储到后台，并返回生成的 **订单号** 信息。

2. 进入确认订单页，选择好支付方式，点击提交订单按钮

   **前端：** 发请求携带 **appid（应用标识），订单号，支付方式类型等** 重要信息。

   **后端：** 校验相关信息，返回 **是否可以支付，支付方式等** 信息。

   **前端:**  根据后端返回的校验结果，比对支付方式等，拉起相应支付方式模块

3. 对接官方进行支付

   **前端：** 获取用户支付密码，发请求 **携带密码，金额等** 对接支付官方接口。将结果状态同步到后端。

   **后端：** 根据前端发送的支付结果，更改订单状态。